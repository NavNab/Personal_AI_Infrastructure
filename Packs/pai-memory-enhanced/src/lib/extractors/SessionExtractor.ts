/**
 * Session Extractor
 *
 * Extracts meaningful patterns from session events and generates
 * structured session summaries for the MEMORY/sessions directory.
 */

import type { SessionGroup } from '../parsers/RawEventParser';
import { getSessionDuration } from '../parsers/RawEventParser';

export interface SessionSummary {
  sessionId: string;
  date: string;
  startTime: string;
  endTime: string;
  durationMinutes: number;
  sourceApp: string;
  workingDirs: string[];
  toolUsage: { tool: string; count: number }[];
  eventCounts: { type: string; count: number }[];
  activityLevel: 'low' | 'medium' | 'high';
  primaryProject: string | null;
}

/**
 * Extract summary from a session group
 */
export function extractSessionSummary(session: SessionGroup): SessionSummary {
  const duration = getSessionDuration(session);
  const eventCount = session.events.length;

  // Count events by type
  const eventTypeCounts = new Map<string, number>();
  for (const event of session.events) {
    const type = event.hook_event_type;
    eventTypeCounts.set(type, (eventTypeCounts.get(type) || 0) + 1);
  }

  // Determine activity level
  let activityLevel: 'low' | 'medium' | 'high' = 'low';
  if (eventCount > 100) activityLevel = 'high';
  else if (eventCount > 30) activityLevel = 'medium';

  // Detect primary project from working dirs
  const primaryProject = detectPrimaryProject(Array.from(session.workingDirs));

  return {
    sessionId: session.sessionId,
    date: session.startTime.slice(0, 10),
    startTime: session.startTime,
    endTime: session.endTime,
    durationMinutes: duration,
    sourceApp: session.sourceApp,
    workingDirs: Array.from(session.workingDirs),
    toolUsage: Array.from(session.toolsUsed.entries())
      .map(([tool, count]) => ({ tool, count }))
      .sort((a, b) => b.count - a.count),
    eventCounts: Array.from(eventTypeCounts.entries())
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count),
    activityLevel,
    primaryProject,
  };
}

/**
 * Detect primary project from working directories
 */
function detectPrimaryProject(workingDirs: string[]): string | null {
  if (workingDirs.length === 0) return null;

  // Use the most specific (deepest) directory as primary
  const sorted = workingDirs.sort((a, b) => b.length - a.length);
  const primary = sorted[0];

  // Extract project name from path
  const parts = primary.split('/').filter(Boolean);
  return parts[parts.length - 1] || null;
}

/**
 * Generate markdown summary for a single session
 */
export function generateSessionMarkdown(summary: SessionSummary): string {
  const lines: string[] = [];

  lines.push(`## Session ${summary.sessionId.slice(0, 8)}`);
  lines.push('');
  lines.push(`**Time:** ${formatTime(summary.startTime)} - ${formatTime(summary.endTime)} (${summary.durationMinutes} min)`);
  lines.push(`**App:** ${summary.sourceApp}`);
  lines.push(`**Activity:** ${summary.activityLevel}`);

  if (summary.primaryProject) {
    lines.push(`**Project:** ${summary.primaryProject}`);
  }

  if (summary.workingDirs.length > 0) {
    lines.push('');
    lines.push('### Working Directories');
    for (const dir of summary.workingDirs.slice(0, 5)) {
      lines.push(`- \`${dir}\``);
    }
    if (summary.workingDirs.length > 5) {
      lines.push(`- ... and ${summary.workingDirs.length - 5} more`);
    }
  }

  if (summary.toolUsage.length > 0) {
    lines.push('');
    lines.push('### Tools Used');
    for (const { tool, count } of summary.toolUsage.slice(0, 10)) {
      lines.push(`- ${tool}: ${count}`);
    }
  }

  lines.push('');
  return lines.join('\n');
}

/**
 * Generate daily summary markdown combining all sessions
 */
export function generateDailySummaryMarkdown(
  date: string,
  sessions: SessionSummary[]
): string {
  const lines: string[] = [];

  lines.push(`# Session Summary - ${date}`);
  lines.push('');
  lines.push(`> Auto-generated by SessionSynthesizer`);
  lines.push('');

  // Daily stats
  const totalDuration = sessions.reduce((sum, s) => sum + s.durationMinutes, 0);
  const totalEvents = sessions.reduce(
    (sum, s) => sum + s.eventCounts.reduce((e, c) => e + c.count, 0),
    0
  );

  lines.push('## Overview');
  lines.push('');
  lines.push(`- **Sessions:** ${sessions.length}`);
  lines.push(`- **Total Duration:** ${totalDuration} minutes`);
  lines.push(`- **Total Events:** ${totalEvents}`);
  lines.push('');

  // Aggregate tool usage across all sessions
  const toolTotals = new Map<string, number>();
  for (const session of sessions) {
    for (const { tool, count } of session.toolUsage) {
      toolTotals.set(tool, (toolTotals.get(tool) || 0) + count);
    }
  }

  if (toolTotals.size > 0) {
    lines.push('## Tool Usage Summary');
    lines.push('');
    const sortedTools = Array.from(toolTotals.entries()).sort((a, b) => b[1] - a[1]);
    for (const [tool, count] of sortedTools.slice(0, 15)) {
      lines.push(`- **${tool}:** ${count}`);
    }
    lines.push('');
  }

  // Unique projects
  const projects = new Set(sessions.map((s) => s.primaryProject).filter(Boolean));
  if (projects.size > 0) {
    lines.push('## Projects Worked On');
    lines.push('');
    for (const project of projects) {
      lines.push(`- ${project}`);
    }
    lines.push('');
  }

  // Individual sessions
  lines.push('---');
  lines.push('');
  lines.push('# Individual Sessions');
  lines.push('');

  for (const session of sessions) {
    lines.push(generateSessionMarkdown(session));
  }

  return lines.join('\n');
}

/**
 * Format ISO timestamp to readable time
 */
function formatTime(isoTimestamp: string): string {
  const date = new Date(isoTimestamp);
  return date.toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  });
}
